"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToInferred = convertToInferred;
const devkit_1 = require("@nx/devkit");
const aggregate_log_util_1 = require("@nx/devkit/src/generators/plugin-migrations/aggregate-log-util");
const executor_to_plugin_migrator_1 = require("@nx/devkit/src/generators/plugin-migrations/executor-to-plugin-migrator");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const plugin_1 = require("../../plugins/plugin");
const versions_1 = require("../../utils/versions");
const utils_1 = require("./utils");
async function convertToInferred(tree, options) {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    const migrationContext = {
        logger: new aggregate_log_util_1.AggregatedLog(),
        projectGraph,
        workspaceRoot: tree.root,
    };
    const migratedProjects = await (0, executor_to_plugin_migrator_1.migrateProjectExecutorsToPlugin)(tree, projectGraph, '@nx/webpack/plugin', plugin_1.createNodesV2, {
        buildTargetName: 'build',
        previewTargetName: 'preview',
        serveStaticTargetName: 'serve-static',
        serveTargetName: 'serve',
    }, [
        {
            executors: ['@nx/webpack:webpack', '@nrwl/webpack:webpack'],
            postTargetTransformer: (0, utils_1.buildPostTargetTransformerFactory)(migrationContext),
            targetPluginOptionMapper: (target) => ({ buildTargetName: target }),
            skipProjectFilter: skipProjectFilterFactory(tree),
        },
        {
            executors: ['@nx/webpack:dev-server', '@nrwl/webpack:dev-server'],
            postTargetTransformer: (0, utils_1.servePostTargetTransformerFactory)(migrationContext),
            targetPluginOptionMapper: (target) => ({ serveTargetName: target }),
            skipProjectFilter: skipProjectFilterFactory(tree),
        },
    ], options.project);
    if (migratedProjects.size === 0) {
        throw new Error('Could not find any targets to migrate.');
    }
    const installCallback = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { 'webpack-cli': versions_1.webpackCliVersion }, undefined, true);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(installCallback, () => {
        migrationContext.logger.flushLogs();
    });
}
function skipProjectFilterFactory(tree) {
    return function skipProjectFilter(projectConfiguration) {
        const buildTarget = Object.values(projectConfiguration.targets).find((target) => target.executor === '@nx/webpack:webpack' ||
            target.executor === '@nrwl/webpack:webpack');
        // the projects for which this is called are guaranteed to have a build target
        const webpackConfigPath = buildTarget.options.webpackConfig;
        if (!webpackConfigPath) {
            return `The webpack config path is missing in the project configuration (${projectConfiguration.root}).`;
        }
        const sourceFile = tsquery_1.tsquery.ast(tree.read(webpackConfigPath, 'utf-8'));
        const composePluginsSelector = 'CallExpression:has(Identifier[name=composePlugins])';
        const composePlugins = (0, tsquery_1.tsquery)(sourceFile, composePluginsSelector)[0];
        if (composePlugins) {
            return `The webpack config (${webpackConfigPath}) can only work with the  "@nx/webpack:webpack" executor. Run the "@nx/webpack:convert-config-to-webpack-plugin" generator first.`;
        }
        const nxAppWebpackPluginSelector = 'PropertyAssignment:has(Identifier[name=plugins]) NewExpression:has(Identifier[name=NxAppWebpackPlugin])';
        const nxAppWebpackPlugin = (0, tsquery_1.tsquery)(sourceFile, nxAppWebpackPluginSelector)[0];
        if (!nxAppWebpackPlugin) {
            return `No "NxAppWebpackPlugin" found in the webpack config (${webpackConfigPath}). Its usage is required for the migration to work.`;
        }
        return false;
    };
}
